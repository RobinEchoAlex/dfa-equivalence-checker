package main.algorithm;

import main.entity.Dfa;
import main.entity.State;
import main.entity.Transition;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static main.algorithm.Util.findState;

public class DfaAlgorithm {
    private boolean isEmptiness =true;

    public Dfa complementationComputation(final Dfa dfa) {
        List<State> finalStates = dfa.getStates().stream().filter(
                state -> !dfa.getFinalStates().contains(state)
        ).collect(Collectors.toList());

        return new Dfa(dfa.getStates(), dfa.getStartState(), finalStates, dfa.getAlphabet());
    }

    public Dfa intersectionComputation(Dfa dfa1, Dfa dfa2) {
        List<State> states = new ArrayList<>();
        State startStates = null;
        List<State> finalStates = new ArrayList<>();


        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                //Create new state whose name is generated by id concatenation
                State state = new State("(" + state1.getId() + "," + state2.getId() + ")");
                states.add(state);

                //If both state is the start state in its DFA, declare this compound state is the SS for new DFA.
                if (dfa1.getStartState().equals(state1) && dfa2.getStartState().equals(state2)) {
                    //Paradox arises if there is two start state for new DFA
                    if (startStates != null) {
                        throw new AssertionError("Duplicate start states");
                    }
                    startStates = state;
                }

                //If both state is final state in respective DFA, this compound state is a final state.
                if (dfa1.getFinalStates().contains(state1) && dfa2.getFinalStates().contains(state2)) {
                    finalStates.add(state);
                }
            }
        }

        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                for (Transition transition1 : state1.getTransitions()) {
                    for (Transition transition2 : state2.getTransitions()) {
                        if (transition1.getSymbol().equals(transition2.getSymbol())) {
                            String startStateName = "(" + state1.getId() + "," + state2.getId() + ")";
                            String endStateName = "(" + transition1.getEndState().getId() + "," + transition2.getEndState().getId() + ")";
                            State startState = findState(states, startStateName);
                            startState.addTransition(new Transition(startState,
                                    transition1.getSymbol(),
                                    findState(states,endStateName)
                                    ));
                        }

                    }
                }
            }
        }

        //TODO alphabet sequence problem analysis
        Dfa dfa = new Dfa(states, startStates, finalStates, dfa1.getAlphabet());
        //Main.printDfaOnScreen(dfa);
        return dfa;
    }

    public Dfa unionComputation(Dfa dfa1, Dfa dfa2) {
        List<State> states = new ArrayList<>();
        State startStates = null;
        List<State> finalStates = new ArrayList<>();


        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                //Create new state whose name is generated by id concatenation
                State state = new State("(" + state1.getId() + "," + state2.getId() + ")");
                states.add(state);

                //If both state is the start state in its DFA, declare this compound state is the SS for new DFA.
                if (dfa1.getStartState().equals(state1) && dfa2.getStartState().equals(state2)) {
                    //Paradox arises if there is two start state for new DFA
                    if (startStates != null) {
                        throw new AssertionError("Duplicate start states");
                    }
                    startStates = state;
                }

                //If either state is final state, this compound state is a final state.
                if (dfa1.getFinalStates().contains(state1) || dfa2.getFinalStates().contains(state2)) {
                    finalStates.add(state);
                }
            }
        }

        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                for (Transition transition1 : state1.getTransitions()) {
                    for (Transition transition2 : state2.getTransitions()) {
                        if (transition1.getSymbol().equals(transition2.getSymbol())) {
                            String startStateName = "(" + state1.getId() + "," + state2.getId() + ")";
                            String endStateName = "(" + transition1.getEndState().getId() + "," + transition2.getEndState().getId() + ")";
                            State startState = findState(states, startStateName);
                            startState.addTransition(new Transition(startState,
                                    transition1.getSymbol(),
                                    findState(states,endStateName)
                            ));
                        }

                    }
                }
            }
        }
        Dfa dfa = new Dfa(states, startStates, finalStates, dfa1.getAlphabet());
        //Main.printDfaOnScreen(dfa);
        return dfa;
    }

    public Dfa symmetricDifference(Dfa dfa1, Dfa dfa2) {
        //FIXME different result if change order
        return unionComputation(
                intersectionComputation(complementationComputation(dfa1),dfa2),
                intersectionComputation(dfa1,complementationComputation(dfa2))
        );
    }

    /**
     * Ver
     * @param dfa
     * @return true if L(M) is empty set.
     */
    public boolean emptinessVerification(Dfa dfa,Consumer<List<Transition>> actionWhenNoEmpty) {
        if (dfa.getFinalStates().contains(dfa.getStartState())) {
            actionWhenNoEmpty.accept(null);
            return false;
        }

        boolean[] visited = new boolean[dfa.getStates().size()];
        List<Transition> path = new ArrayList<>();
        dfsRecursion(dfa,dfa.getStartState(), visited, path, actionWhenNoEmpty);
        return isEmptiness;
    }

    private void dfsRecursion(Dfa dfa, State currentState, boolean[] isVisited, List<Transition> path, Consumer<List<Transition>> actionWhenNoEmpty) {
        isVisited[dfa.getStates().indexOf(currentState)] = true;

        //It is the end state
        if (dfa.getFinalStates().contains(currentState)) {
            isEmptiness = false;
            actionWhenNoEmpty.accept(path);
        }

        for (Transition trans : currentState.getTransitions()) {
            State endState = trans.getEndState();
            if (!isVisited[dfa.getStates().indexOf(endState)]) {
                path.add(trans);
                dfsRecursion(dfa, endState, isVisited, path, actionWhenNoEmpty);
                path.remove(trans);
            }
        }
    }

    public boolean equivalence(Dfa dfa1, Dfa dfa2) {
        //TODO if the alphabet is not equal, return immediately
        return emptinessVerification(symmetricDifference(dfa1, dfa2), DfaAlgorithm::declareNonEquivalent);
    }

    public static void printRoute(List<Transition> path) {
        System.out.print("language non-empty - ");
        if (path == null) {
            System.out.println("e");
        }
        else for (Transition transition: path) {
            System.out.print(transition.getSymbol());
        }
        System.out.println(" accepted");
        System.exit(0);
    }

    public static void declareNonEquivalent(List<Transition> path) {
        System.out.println("not equivalent");
        System.exit(0);
    }
}
