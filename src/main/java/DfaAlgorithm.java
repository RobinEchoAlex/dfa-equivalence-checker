package main.java;

import main.entity.Dfa;
import main.entity.State;
import main.entity.Transition;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.stream.Collectors;

import static main.java.Util.findState;

public class DfaAlgorithm {

    public Dfa complementationComputation(final Dfa dfa) {
        List<State> finalStates = dfa.getStates().stream().filter(
                state -> !dfa.getFinalStates().contains(state)
        ).collect(Collectors.toList());

        return new Dfa(dfa.getStates(), dfa.getStartState(), finalStates, dfa.getAlphabet());
    }

    public Dfa intersectionComputation(Dfa dfa1, Dfa dfa2) {
        List<State> states = new ArrayList<>();
        State startStates = null;
        List<State> finalStates = new ArrayList<>();


        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                //Create new state whose name is generated by id concatenation
                State state = new State("(" + state1.getId() + "," + state2.getId() + ")");
                states.add(state);

                //If both state is the start state in its DFA, declare this compound state is the SS for new DFA.
                if (dfa1.getStartState().equals(state1) && dfa2.getStartState().equals(state2)) {
                    //Paradox arises if there is two start state for new DFA
                    if (startStates != null) {
                        throw new AssertionError("Duplicate start states");
                    }
                    startStates = state;
                }

                //If both state is final state in respective DFA, this compound state is a final state.
                if (dfa1.getFinalStates().contains(state1) && dfa2.getFinalStates().contains(state2)) {
                    finalStates.add(state);
                }
            }
        }

        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                for (Transition transition1 : state1.getTransitions()) {
                    for (Transition transition2 : state2.getTransitions()) {
                        if (transition1.getSymbol().equals(transition2.getSymbol())) {
                            String startStateName = "(" + state1.getId() + "," + state2.getId() + ")";
                            String endStateName = "(" + transition1.getEndState().getId() + "," + transition2.getEndState().getId() + ")";
                            State startState = findState(states, startStateName);
                            startState.addTransition(new Transition(startState,
                                    transition1.getSymbol(),
                                    findState(states,endStateName)
                                    ));
                        }

                    }
                }
            }
        }

        //TODO alphabet sequence problem analysis
        Dfa dfa = new Dfa(states, startStates, finalStates, dfa1.getAlphabet());
        Main.printDfaOnScreen(dfa);
        return dfa;
    }

    public Dfa unionComputation(Dfa dfa1, Dfa dfa2) {
        List<State> states = new ArrayList<>();
        State startStates = null;
        List<State> finalStates = new ArrayList<>();


        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                //Create new state whose name is generated by id concatenation
                State state = new State("(" + state1.getId() + "," + state2.getId() + ")");
                states.add(state);

                //If both state is the start state in its DFA, declare this compound state is the SS for new DFA.
                if (dfa1.getStartState().equals(state1) && dfa2.getStartState().equals(state2)) {
                    //Paradox arises if there is two start state for new DFA
                    if (startStates != null) {
                        throw new AssertionError("Duplicate start states");
                    }
                    startStates = state;
                }

                //If either state is final state, this compound state is a final state.
                if (dfa1.getFinalStates().contains(state1) || dfa2.getFinalStates().contains(state2)) {
                    finalStates.add(state);
                }
            }
        }

        for (State state1 : dfa1.getStates()) {
            for (State state2 : dfa2.getStates()) {
                for (Transition transition1 : state1.getTransitions()) {
                    for (Transition transition2 : state2.getTransitions()) {
                        if (transition1.getSymbol().equals(transition2.getSymbol())) {
                            String startStateName = "(" + state1.getId() + "," + state2.getId() + ")";
                            String endStateName = "(" + transition1.getEndState().getId() + "," + transition2.getEndState().getId() + ")";
                            State startState = findState(states, startStateName);
                            startState.addTransition(new Transition(startState,
                                    transition1.getSymbol(),
                                    findState(states,endStateName)
                            ));
                        }

                    }
                }
            }
        }
        Dfa dfa = new Dfa(states, startStates, finalStates, dfa1.getAlphabet());
        Main.printDfaOnScreen(dfa);
        return dfa;
    }

    public Dfa symmetricDifference(Dfa dfa1, Dfa dfa2) {
        //FIXME different result if change order
        return unionComputation(
                intersectionComputation(complementationComputation(dfa1),dfa2),
                intersectionComputation(dfa1,complementationComputation(dfa2))
        );


    }

    /**
     *
     * @param dfa
     * @return true if L(M) is empty set.
     */
    public boolean emptinessVerification(Dfa dfa) {
        boolean visited[] = new boolean[dfa.getStates().size()];
        Stack<State> statesToGo = new Stack<>();
        statesToGo.push(dfa.getStartState());

        while (!statesToGo.isEmpty()) {
            State state = statesToGo.pop();
            visited[dfa.getStates().indexOf(state)] = true;

            for (Transition trans : state.getTransitions()) {
                State endState = trans.getEndState();
                //It is the end state
                if (dfa.getFinalStates().contains(endState)) {
                    System.out.println("end stae");
                    System.out.println(endState.getId());
                    System.out.println("current st");
                    System.out.println(state.getId());
                    return false;
                }

                if (!visited[dfa.getStates().indexOf(endState)]) {
                    statesToGo.push(endState);
                }
            }
        }
        return true;
    }

    private void dfsRecrusion(State currentState,boolean isVisited[],List<Integer> path) {

    }

    public boolean equivalence(Dfa dfa1, Dfa dfa2) {
        return emptinessVerification(symmetricDifference(dfa1, dfa2));
    }
}
